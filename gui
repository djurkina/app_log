import tkinter as tk
from tkinter import messagebox, simpledialog, scrolledtext, ttk
import threading
import time
import json
from datetime import datetime

from drive_service import (
    extract_file_id, extract_folder_id, list_files_in_folder,
    copy_file, move_file, delete_file, set_file_permission,
    get_file_hierarchy, copy_new_items
)
from config import GOOGLE_ROOT_ID

# Файлы для хранения задач мониторинга и журнала изменений
MONITOR_TASKS_FILE = "monitor_tasks.json"
CHANGES_LOG_FILE = "changes_log.json"


def load_json(filepath: str):
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return []


def save_json(filepath: str, data):
    try:
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"Ошибка записи файла {filepath}: {e}")


def add_change_record(operation, file_name, file_id, source_id="", dest_id="", comment=""):
    log_data = load_json(CHANGES_LOG_FILE)
    record = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "operation": operation,
        "file_name": file_name,
        "file_id": file_id,
        "source_folder_id": source_id,
        "dest_folder_id": dest_id,
        "comment": comment
    }
    log_data.append(record)
    save_json(CHANGES_LOG_FILE, log_data)


def add_monitor_task(source_id, dest_id, copied_map=None):
    if copied_map is None:
        copied_map = {}
    tasks = load_json(MONITOR_TASKS_FILE)
    for t in tasks:
        if t["source_folder_id"] == source_id and t["dest_folder_id"] == dest_id:
            return False
    tasks.append({
        "source_folder_id": source_id,
        "dest_folder_id": dest_id,
        "copied_files": copied_map
    })
    save_json(MONITOR_TASKS_FILE, tasks)
    return True


def remove_monitor_task(source_id, dest_id):
    tasks = load_json(MONITOR_TASKS_FILE)
    new_tasks = []
    removed = False
    for t in tasks:
        if t["source_folder_id"] == source_id and t["dest_folder_id"] == dest_id:
            removed = True
            continue
        new_tasks.append(t)
    if removed:
        save_json(MONITOR_TASKS_FILE, new_tasks)
    return removed


def get_monitor_tasks():
    return load_json(MONITOR_TASKS_FILE)


def check_monitor_tasks(log_callback):
    tasks = load_json(MONITOR_TASKS_FILE)
    updated = False
    for task in tasks:
        source_id = task["source_folder_id"]
        dest_id = task["dest_folder_id"]
        copied_map = task.get("copied_files", {})
        try:
            new_map = copy_new_items(source_id, dest_id, copied_map.copy(), base_path="")
        except Exception as e:
            log_callback(f"[Мониторинг] Ошибка копирования: {e}")
            continue
        if len(new_map) > len(copied_map):
            task["copied_files"] = new_map
            updated = True
            log_callback(f"[Мониторинг] Обнаружены и скопированы новые файлы/папки.")
    if updated:
        save_json(MONITOR_TASKS_FILE, tasks)


def monitor_worker(log_callback):
    while True:
        check_monitor_tasks(log_callback)
        time.sleep(10)


class DriveApp:
    def __init__(self, master):
        self.master = master
        master.title("Google Drive Manager")
        master.geometry("800x600")

        self.frame_commands = tk.Frame(master)
        self.frame_commands.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

        # Команды: оставлены только базовые и новая кнопка "Отменить все операции"
        commands = [
            ("Copy", self.copy_files),
            ("Monitor", self.show_monitor_tasks),
            ("AddMonitor", self.add_monitor_task_cmd),
            ("RemoveMonitor", self.remove_monitor_task_cmd),
            ("Report", self.show_report),
            ("SetPermissions", self.set_permissions),
            ("Отменить все операции", self.cancel_all_operations)
        ]
        for (text, cmd) in commands:
            btn = tk.Button(self.frame_commands, text=text, width=20, command=cmd)
            btn.pack(side=tk.LEFT, padx=5)

        self.log_area = scrolledtext.ScrolledText(master, width=100, height=25)
        self.log_area.pack(padx=10, pady=10)

        self.monitor_thread = threading.Thread(target=monitor_worker, args=(self.threadsafe_log,), daemon=True)
        self.monitor_thread.start()

    def threadsafe_log(self, message):
        self.master.after(0, lambda: self.log(message))

    def log(self, message):
        self.log_area.insert(tk.END, message + "\n")
        self.log_area.see(tk.END)

    def copy_files(self):
        source_link = simpledialog.askstring("Copy", "Введите ссылку на исходную папку:")
        if source_link is None:
            return
        dest_link = simpledialog.askstring("Copy", "Введите ссылку на целевую папку (оставьте пустым для корневой):")
        if dest_link is None:
            return

        source_id = extract_folder_id(source_link)
        if not source_id:
            messagebox.showerror("Ошибка", "Не удалось извлечь ID исходной папки.")
            return
        if dest_link.strip() == "":
            dest_id = GOOGLE_ROOT_ID
        else:
            dest_id = extract_folder_id(dest_link)
            if not dest_id:
                messagebox.showerror("Ошибка", "Не удалось извлечь ID целевой папки.")
                return

        def worker():
            self.threadsafe_log("Начинаем рекурсивное копирование (Copy)...")
            try:
                copied_map = copy_new_items(source_id, dest_id, {}, base_path="")
                self.threadsafe_log(f"Копирование завершено. Скопировано объектов: {len(copied_map)}")
                tasks = get_monitor_tasks()
                exists = any(t["source_folder_id"] == source_id and t["dest_folder_id"] == dest_id for t in tasks)
                if not exists:
                    add_monitor_task(source_id, dest_id, copied_map)
                    self.threadsafe_log("Задача мониторинга создана.")
                add_change_record("copy", "(множество объектов)", "(множество)", source_id, dest_id, "Рекурсивное копирование через Copy")
            except Exception as e:
                self.threadsafe_log(f"Ошибка при копировании: {e}")

        threading.Thread(target=worker, daemon=True).start()

    def show_monitor_tasks(self):
        tasks = get_monitor_tasks()
        if not tasks:
            messagebox.showinfo("Monitor", "Нет мониторинговых задач.")
            return
        win = tk.Toplevel(self.master)
        win.title("Мониторинговые задачи")
        tree = ttk.Treeview(win, columns=("Source", "Destination", "CopiedCount"), show="headings")
        tree.heading("Source", text="Исходная папка")
        tree.heading("Destination", text="Целевая папка")
        tree.heading("CopiedCount", text="Скопировано объектов")
        tree.pack(fill=tk.BOTH, expand=True)
        for task in tasks:
            tree.insert("", tk.END,
                        values=(
                            task["source_folder_id"],
                            task["dest_folder_id"],
                            len(task.get("copied_files", {}))
                        ))

    def add_monitor_task_cmd(self):
        source_link = simpledialog.askstring("AddMonitor", "Введите ссылку на исходную папку:")
        if source_link is None:
            return
        dest_link = simpledialog.askstring("AddMonitor", "Введите ссылку на целевую папку (оставьте пустым для корневой):")
        if dest_link is None:
            return

        source_id = extract_folder_id(source_link)
        if not source_id:
            messagebox.showerror("Ошибка", "Не удалось извлечь ID исходной папки.")
            return
        if dest_link.strip() == "":
            dest_id = GOOGLE_ROOT_ID
        else:
            dest_id = extract_folder_id(dest_link)
            if not dest_id:
                messagebox.showerror("Ошибка", "Не удалось извлечь ID целевой папки.")
                return

        def worker():
            self.threadsafe_log("Идёт первичное копирование для AddMonitor...")
            try:
                copied_map = copy_new_items(source_id, dest_id, {}, base_path="")
                self.threadsafe_log(f"Первичное копирование завершено. Скопировано объектов: {len(copied_map)}")
                if add_monitor_task(source_id, dest_id, copied_map):
                    self.threadsafe_log(f"Новая задача мониторинга добавлена:\nИсходная: {source_id}\nЦелевая: {dest_id}")
                else:
                    self.threadsafe_log("Такая задача уже существует!")
            except Exception as e:
                self.threadsafe_log(f"Ошибка при первоначальном копировании: {e}")

        threading.Thread(target=worker, daemon=True).start()

    def remove_monitor_task_cmd(self):
        source_link = simpledialog.askstring("RemoveMonitor", "Введите ссылку на исходную папку:")
        if source_link is None:
            return
        dest_link = simpledialog.askstring("RemoveMonitor", "Введите ссылку на целевую папку (оставьте пустым для корневой):")
        if dest_link is None:
            return

        source_id = extract_folder_id(source_link)
        if not source_id:
            messagebox.showerror("Ошибка", "Не удалось извлечь ID исходной папки.")
            return
        if dest_link.strip() == "":
            dest_id = GOOGLE_ROOT_ID
        else:
            dest_id = extract_folder_id(dest_link)
            if not dest_id:
                messagebox.showerror("Ошибка", "Не удалось извлечь ID целевой папки.")
                return

        removed = remove_monitor_task(source_id, dest_id)
        if removed:
            self.log(f"Задача мониторинга удалена:\nИсходная: {source_id}\nЦелевая: {dest_id}")
        else:
            self.log("Задача мониторинга с такими путями не найдена.")

    def cancel_all_operations(self):
        """
        Удаляет все объекты, скопированные через AddMonitor, и очищает задачи мониторинга.
        """
        self.log("Запуск отмены всех операций...")
        tasks = get_monitor_tasks()
        if not tasks:
            self.log("Нет задач мониторинга для отмены.")
            return
        for task in tasks:
            copied_map = task.get("copied_files", {})
            for rel_path, obj_id in copied_map.items():
                try:
                    delete_file(obj_id)
                    self.log(f"Удалён объект {rel_path} (ID: {obj_id})")
                except Exception as e:
                    self.log(f"Ошибка при удалении объекта {rel_path}: {e}")
        # Очистить файл задач мониторинга
        save_json(MONITOR_TASKS_FILE, [])
        self.log("Все задачи мониторинга отменены, все скопированные объекты удалены.")

    def show_report(self):
        changes = load_json(CHANGES_LOG_FILE)
        report_lines = ["==== Полный отчёт по изменениям ===="]
        report_lines.append(f"Google Root ID: {GOOGLE_ROOT_ID}")
        report_lines.append("")
        if changes:
            for rec in sorted(changes, key=lambda x: x["timestamp"]):
                line = f"{rec['timestamp']} | {rec['operation']} | Файл: {rec['file_name']} (ID: {rec['file_id']})"
                if rec['source_folder_id']:
                    line += f" | От: {rec['source_folder_id']}"
                if rec['dest_folder_id']:
                    line += f" | В: {rec['dest_folder_id']}"
                if rec['comment']:
                    line += f" | {rec['comment']}"
                report_lines.append(line)
        else:
            report_lines.append("Журнал изменений пуст.")
        report = "\n".join(report_lines)
        win = tk.Toplevel(self.master)
        win.title("Отчёт изменений")
        txt = scrolledtext.ScrolledText(win, width=100, height=30)
        txt.insert(tk.END, report)
        txt.pack()

    def set_permissions(self):
        file_link = simpledialog.askstring("SetPermissions", "Введите ссылку на файл (или папку):")
        if not file_link:
            return
        file_id = extract_file_id(file_link)
        if not file_id:
            file_id = extract_folder_id(file_link)
            if not file_id:
                messagebox.showerror("Ошибка", "Не удалось извлечь ID файла/папки.")
                return
        email = simpledialog.askstring("SetPermissions", "Введите email пользователя:")
        if not email:
            return
        role = simpledialog.askstring("SetPermissions", "Введите роль (reader, writer, owner):")
        if not role or role.lower() not in ['reader', 'writer', 'owner']:
            messagebox.showerror("Ошибка", "Некорректная роль.")
            return
        try:
            perm_id = set_file_permission(file_id, email, role.lower())
            self.log(f"Права успешно изменены. ID разрешения: {perm_id}")
            add_change_record("setpermissions", "(unknown)", file_id, comment=f"Права {role} для {email}")
            messagebox.showinfo("SetPermissions", "Права успешно изменены.")
        except Exception as e:
            self.log(f"Ошибка при изменении прав: {e}")
            messagebox.showerror("Ошибка", "Ошибка при изменении прав.")


if __name__ == '__main__':
    root = tk.Tk()
    app = DriveApp(root)
    root.mainloop()
